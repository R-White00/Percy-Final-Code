{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport React, { useContext, useMemo } from 'react';\nimport { polarToCartesian } from \"./utils\";\nimport { G, Line, Text } from 'react-native-svg';\nimport Context from \"./context\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\n\nvar getMarkPosition = function getMarkPosition(angle, offset, radius) {\n  return polarToCartesian(radius, radius, radius + offset, angle);\n};\n\nexport default function Marks(_ref) {\n  var _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 10 : _ref$step,\n      _ref$lineCap = _ref.lineCap,\n      lineCap = _ref$lineCap === void 0 ? 'butt' : _ref$lineCap,\n      _ref$lineColor = _ref.lineColor,\n      lineColor = _ref$lineColor === void 0 ? 'white' : _ref$lineColor,\n      _ref$lineOpacity = _ref.lineOpacity,\n      lineOpacity = _ref$lineOpacity === void 0 ? 1 : _ref$lineOpacity,\n      _ref$numbersRadius = _ref.numbersRadius,\n      numbersRadius = _ref$numbersRadius === void 0 ? 17 : _ref$numbersRadius,\n      _ref$fontSize = _ref.fontSize,\n      fontSize = _ref$fontSize === void 0 ? 18 : _ref$fontSize,\n      _ref$lineSize = _ref.lineSize,\n      lineSize = _ref$lineSize === void 0 ? 12 : _ref$lineSize,\n      children = _ref.children;\n\n  var _useContext = useContext(Context),\n      rotation = _useContext.rotation,\n      min = _useContext.min,\n      max = _useContext.max,\n      angle = _useContext.angle,\n      radius = _useContext.radius,\n      fontFamily = _useContext.fontFamily;\n\n  var marks = useMemo(function () {\n    var stepsLength = Math.round((max - min) / step);\n    var gap = angle / stepsLength;\n    return _toConsumableArray(Array(stepsLength + 1)).map(function (val, index) {\n      var actualAngle = gap * index;\n      var isEven = index % 2 == 0;\n      var size = isEven ? lineSize : lineSize - 5;\n\n      var _getMarkPosition = getMarkPosition(actualAngle, 0, radius),\n          x1 = _getMarkPosition.x,\n          y1 = _getMarkPosition.y;\n\n      var _getMarkPosition2 = getMarkPosition(actualAngle, -size, radius),\n          x2 = _getMarkPosition2.x,\n          y2 = _getMarkPosition2.y;\n\n      var _getMarkPosition3 = getMarkPosition(actualAngle, -lineSize - numbersRadius, radius),\n          x = _getMarkPosition3.x,\n          y = _getMarkPosition3.y;\n\n      return {\n        coordinates: {\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2\n        },\n        isEven: isEven,\n        textProps: {\n          x: x,\n          y: y,\n          transform: \"rotate(\" + (360 - rotation) + \", \" + x + \", \" + y + \")\"\n        },\n        value: Math.round(index * step + min)\n      };\n    });\n  }, [max, min, step, radius, rotation, angle, lineSize]);\n  if (children) return marks.map(children);\n  return marks.map(function (mark, i) {\n    return _jsxs(G, {\n      children: [_jsx(Line, _objectSpread(_objectSpread({}, mark.coordinates), {}, {\n        stroke: lineColor,\n        strokeWidth: mark.isEven ? 3 : 2,\n        strokeOpacity: lineOpacity,\n        strokeLinecap: lineCap\n      })), mark.isEven && _jsx(Text, _objectSpread(_objectSpread({}, mark.textProps), {}, {\n        fill: \"white\",\n        textAnchor: \"middle\",\n        alignmentBaseline: \"middle\",\n        fontFamily: fontFamily,\n        opacity: 0.8,\n        fontSize: fontSize,\n        children: mark.value\n      }))]\n    }, i);\n  });\n}","map":{"version":3,"sources":["C:/Users/black/Documents/Uni Notes/GDP/Dashboard/percy_dashboard/node_modules/react-native-cool-speedometer/src/Marks.js"],"names":["React","useContext","useMemo","polarToCartesian","G","Line","Text","Context","getMarkPosition","angle","offset","radius","Marks","step","lineCap","lineColor","lineOpacity","numbersRadius","fontSize","lineSize","children","rotation","min","max","fontFamily","marks","stepsLength","Math","round","gap","Array","map","val","index","actualAngle","isEven","size","x1","x","y1","y","x2","y2","coordinates","textProps","transform","value","mark","i"],"mappings":"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","sourcesContent":["import React, { useContext, useMemo } from 'react'\nimport { polarToCartesian } from './utils'\nimport { G, Line, Text } from 'react-native-svg'\nimport Context from './context'\n\nconst getMarkPosition = (angle, offset, radius) => {\n  return polarToCartesian(\n    radius,\n    radius,\n    radius + offset,\n    angle\n  )\n}\n\nexport default function Marks({\n  step = 10,\n  lineCap = 'butt',\n  lineColor = 'white',\n  lineOpacity = 1,\n  numbersRadius = 17,\n  fontSize = 18,\n  lineSize = 12,\n  children,\n}) {\n\n  const {\n    rotation,\n    min,\n    max,\n    angle,\n    radius,\n    fontFamily\n  } = useContext(Context)\n\n  const marks = useMemo(() => { \n    const stepsLength = Math.round((max - min) / step)\n    const gap = angle / stepsLength\n\n    return [...Array(stepsLength + 1)].map((val, index) => {\n      const actualAngle = gap * index\n      const isEven = index  % 2 == 0\n      const size = isEven ? lineSize : lineSize - 5\n\n      const {x: x1, y: y1} = getMarkPosition(actualAngle, 0, radius)\n      const {x: x2, y: y2} = getMarkPosition(actualAngle, - size, radius)\n      const { x, y } = getMarkPosition(actualAngle, - lineSize - numbersRadius, radius)\n      \n      return {\n        coordinates: { x1, y1, x2, y2 },\n        isEven,\n        textProps: { x, y, transform: `rotate(${360 - rotation}, ${x}, ${y})` },\n        value: Math.round((index * step) + min)\n      }\n    })\n  }, [max, min, step, radius, rotation, angle, lineSize])\n\n  if (children) return marks.map(children)\n\n  return marks.map((mark, i) => (\n    <G key={i}>\n      <Line\n        {...mark.coordinates}\n        stroke={lineColor}\n        strokeWidth={mark.isEven ? 3 : 2}\n        strokeOpacity={lineOpacity}\n        strokeLinecap={lineCap}\n      />\n      {mark.isEven && (\n        <Text\n          {...mark.textProps}\n          fill=\"white\"\n          textAnchor=\"middle\"\n          alignmentBaseline=\"middle\"\n          fontFamily={fontFamily}\n          opacity={0.8}\n          fontSize={fontSize}\n          children={mark.value}\n        />\n      )}\n    </G>\n  ))\n}"]},"metadata":{},"sourceType":"module"}